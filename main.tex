\newcommand{\citestyle}[1]{}
\documentclass[9pt, sigplan, natbib=false, screen=true]{acmart}
\let\citename\relax

\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}

\acmConference[CoqPL'18]{The Fourth International Workshop on Coq for Programming Languages}{January 2018}{Los Angeles, United States}
\acmYear{2018}
\copyrightyear{2018}

\usepackage{balance}

%\usepackage{fontspec}

\usepackage[
   backend=biber,
   bibencoding=utf8,
   style=alphabetic,
   hyperref=true,
   % citestyle=authoryear-comp,
   backref=false,
   sortlocale=en,
   url=true,
   doi=false,
   eprint=false
 ]{biblatex}
\addbibresource{biblio.bib}

\newcommand\Coq{Coq}
\newcommand\OCaml{OCaml}
\newcommand\R{R}
\newcommand\Cn{C}

\usepackage{minted}
\setminted{encoding=utf8}

\usepackage{tikz}
\usetikzlibrary{positioning}

\tikzset{
	box/.style = {
		draw = black,
        fill = white,
		rectangle,
		rounded corners = 2pt,
		text centered,
		minimum height = 5mm,
		minimum width = 10mm
	}
}

\setcopyright{none}

\title{Building and Trusting \R{} Using \Coq{}}
\author{Martin Bodin}
\email{mbodin@dim.uchile.cl}
\affiliation{
    \institution{Center of Mathematical Modeling}
    \streetaddress{Beauchef 851}
    \city{Santiago}
    \country{Chile}
}

\begin{document}

\begin{abstract}
Real-world programming languages have subtil behaviours.
In particular, their semantics is often associated with
various corner cases.
Programmers are usually unaware of all these corner cases,
which can yield to serious bugs.
This is an opportunity for our community
as \Coq{} provides a way to certify the behaviour of a program.
But if the certified program is not written in \Coq{},
such a certification relies on a formal semantics of its programming language.
In the case of a real-world language, such a semantics
can be as difficult to trust as the original program.
Some previous work proposed ways to trust such large semantics.
This work evaluates the feasibility of such a large-scale formalisation
in the case of the \R{} programming languageâ€”%
a trending programming language specialised for statistics computations.
We introduces ProveR, a formalisation of the core of \R{}
related to the reference \R{} interpreter.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:introduction}

\R{}~\parencite{ihaka1996r, Rwebsite} is a trending
programming language for statisticians.
Its usages range from finance, biology,
as well as big data analyses,
as illustrated by the list of available packages categories~\parencite{rviews}.
Such a diversity of usages makes \R{} unlikely to disappear
in the following years.
As a consequence of this diversity,
\R{} programmers come from very different fields of study,
resulting in largely different programming styles.

The \R{} programming language presents itself
as an expressive and powerful language,
able to express complex notions with few keystrokes.
This powerfulness comes with the cost of readability:
given an \R{} program, it can be difficult to fully
understand what it exactly does.
Furthermore, the semantics of \R{} is subtle
and contains numerous corner cases
(as shown in Section~\ref{sec:presentation}).
%
As a consequence, bugs are frequent when programming in \R{},
and trusting an \R{} program can be difficult.
Formal methods in general and the \Coq{} proof assistant in particular
offer an interesting answer to this trust issue.
But to formally prove that an \R{} program meets its specification,
we need a \Coq{} semantics of \R{}.
Such a semantics needs to be trustworthy.
In particular, it should capture all the corner cases
with which a proven program can cope.

A semantics for the full \R{} language will inevitably
be complex, as all corner cases has to be taken into account.
The question of trusting such a semantics
then naturally arises.
%
To be able to trust such a formalisation,
it is important to identify \emph{trust sources}.
These can be language specification,
test suites,
or reference interpreters.
In the case of \R{}, there is unfortunately
no precise language specification.
There are however some test suites~\parencite{2014testr, maj2013testr},
as well as a reference interpreter~\parencite{team2000r}.

When formalising a complex programming language such as \R{},
defining the formal model itself
is a relatively small part of the formalisation process:
relating it to trust sources
is as least as important as defining the model.
This relation depends on the kind of available trust sources.
%
Specifications are the preferred trust source.
They provide a non-ambigous description of the behaviour of the language constructs.
A formalisation can relate to them by similarity:
the constructs and operations of the formalisation should mimic the ones
of the specification.
Ideally, such a similarity should be a line-to-line closeness,
each line of the formalisation referring to a line of the specification,
and conversely.
%
Test suites provides a large number of programs and their expected result.
When the formalisation is executable, it can be tested against such tests suites.
This technique enables to then evaluate the quality of the test suite
using code coverage.
%
Reference interpreters are particularly interesting as
they can be used in methods similar to specifications and test suites.
It is indeed possible to relate a formal semantics
using the source code of the interpreter,
using it as a specification.
But it is also possible to compare the results of the reference interpreter
and the formal semantics (if executable) on random programs,
until the wanted code coverage is used.

The \R{} language is a large language,
but it contains an easy-to-identify core.
We introduce ProveR, a full \Coq{} specification for this core.
The formalisation presents itself as a monadic interpreter.
This interpreter mimics the operations of the reference interpreter,
using its \Cn{} source code as a specification.
%
The next section presents some of the subtleties of the \R{} programming language.
Then Section~\ref{sec:formalisation} presents how our interpreter is defined,
and in particular, how it is related to the \R{} source code.
This project is still in development
and is available at \url{https://github.com/Mbodin/proveR}.


\section{Quick Presentation of \R{}}
\label{sec:presentation}

Let us now show some of the corner cases of the \R{} semantics.

\R{} subtleties.

\mintinline{R}{i:j}

\begin{minted}{R}
v[i]
\end{minted}

None of these corner cases are inherently complex to deal with:
it is the large amount of such exceptions that makes the language complex.


\section{Formalisation}
\label{sec:formalisation}

Trust source used: eyeball closeness.

Description of the closeness.


\section{Conclusion and Further Work}
\label{sec:conclusion}

The full project graph.
Show that other trust sources are possible.

Say that this approach may be scalable to other projects.


\section{Related Work}
\label{sec:related:work}

There already have been a large amount of \Coq{} formalisations
of real-world languages.

Formalin.
CompCert.

JSCert.

K and its \Coq{} extraction.
K-Java.


\printbibliography

\end{document}

