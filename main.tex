\newcommand{\citestyle}[1]{}
\documentclass[9pt, sigplan, natbib=false]{acmart}
\let\citename\relax

%\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}

\acmConference[CoqPL'18]{The Fourth International Workshop on Coq for Programming Languages}{January 2018}{Los Angeles, United States}
\acmYear{2018}
\copyrightyear{2018}

\usepackage{balance}

%\usepackage{fontspec}

\usepackage[
   backend=biber,
   bibencoding=utf8,
   style=alphabetic,
   hyperref=true,
   % citestyle=authoryear-comp,
   backref=false,
   sortlocale=en,
   url=true,
   doi=false,
   eprint=false
 ]{biblatex}
\addbibresource{biblio.bib}

\newcommand\Coq{Coq}
\newcommand\OCaml{OCaml}
\newcommand\R{R}
\newcommand\Cn{C}

\usepackage{minted}
\setminted{encoding=utf8}

\usepackage{tikz}
\usetikzlibrary{positioning}

\tikzset{
	box/.style = {
		draw = black,
        fill = white,
		rectangle,
		rounded corners = 2pt,
		text centered,
		minimum height = 5mm,
		minimum width = 10mm
	}
}

\setcopyright{none}

\title{Building and Trusting \R{} Using \Coq{}}
\author{Martin Bodin}
\email{mbodin@dim.uchile.cl}
\affiliation{
    \institution{Center of Mathematical Modeling}
    \streetaddress{Beauchef 851}
    \city{Santiago}
    \country{Chile}
}

\begin{document}

\begin{abstract}
Real-world programming languages have subtil behaviours.
In particular, their semantics is often associated with
various corner cases.
Programmers are usually unaware of all these corner cases,
which can yield to serious bugs.
This is an opportunity for our community
as \Coq{} provides a way to certify the behaviour of a program.
But if the certified program is not written in \Coq{},
such a certification relies on a formal semantics of its programming language.
In the case of a real-world language, such a semantics
can be as difficult to trust as the original program.
Some previous work proposed ways to trust such large semantics.
This work evaluates the feasibility of such a large-scale formalisation
in the case of the \R{} programming languageâ€”%
a trending programming language specialised for statistics computations.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:introduction}

\R{}~\parencite{Rwebsite} is a trending programming language for mathematicians.
Its usages range from statistics to finance, biology,
as well as big data analyses
(this can be illustrated by the various groups of available packages:
\url{https://cran.r-project.org/web/views/}).
Such a diversity of usages makes \R{} unlikely to disappear
in the following years.
As a consequence of this diversity,
\R{} programmers come from very different fields of study,
resulting in largely different programming styles.

The \R{} programming language presents itself
as an expressive and powerful language,
able to express complex notions with few keystrokes.
This powerfulness comes with the cost of readability:
given an \R{} program, it can be difficult to fully
understand what it exactly does.
Furthermore, the semantics of \R{} is subtle
and contains numerous corner cases
(as shown in Section~\ref{sec:presentation}).
%
As a consequence, bugs are frequent when programming in \R{},
and trusting an \R{} program can be difficult.
Formal methods in general and the \Coq{} proof assistant in particular
offer an interesting answer to this trust issue.
But to formally prove that an \R{} program meets its specification,
we need a \Coq{} semantics of \R{}.
Such a semantics needs to be trustworthy.
In particular, it should capture all the corner cases
with which a proven program can cope.

A semantics for the full \R{} language will invariably
be quite complex because of all the corner cases
of the language.
The question of trusting such a semantics
then naturally arises.
%
TODO: Discussion about trust sources.

\section{Related Work}
\label{sec:related:work}

There already have been a large amount of \Coq{} formalisations
of real-world languages.

Formalin.
CompCert.

JSCert.

K and its \Coq{} extraction.
K-Java.

\section{Quick Presentation of \R{}}
\label{sec:presentation}

Let us now show some of the corner cases of the \R{} semantics.

\R{} subtleties.

\mintinline{R}{i:j}

\begin{minted}{R}
v[i]
\end{minted}

None of these corner cases are inherently complex to deal with:
it is the large amount of such exceptions that makes the language complex.

\section{Formalisation}
\label{sec:formalisation}

Trust source used: eyeball closeness.

Description of the closeness.

\section{Conclusion and Further Work}
\label{sec:conclusion}

The full project graph.
Show that other trust sources are possible.

Say that this approach may be scalable to other projects.

\printbibliography

\end{document}

