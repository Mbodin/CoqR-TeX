\newcommand{\citestyle}[1]{}
\documentclass[9pt, sigplan, natbib=false, screen=true]{acmart}
\let\citename\relax

\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}
%\pagestyle{plain}

\acmConference[CoqPL'18]{The Fourth International Workshop on Coq for Programming Languages}{January 2018}{Los Angeles, United States}
\acmYear{2018}
\copyrightyear{2018}

\usepackage{balance}

%\usepackage{fontspec}

\usepackage[
   backend=biber,
   bibencoding=utf8,
   style=alphabetic,
   hyperref=true,
   % citestyle=authoryear-comp,
   backref=false,
   sortlocale=en,
   url=true,
   doi=false,
   eprint=false
 ]{biblatex}
\addbibresource{biblio.bib}

\newcommand\Coq{Coq}
\newcommand\OCaml{OCaml}
\newcommand\R{R}
\newcommand\Cn{C}

\usepackage{minted}
\setminted{encoding=utf8}

\usepackage{tikz}
\usetikzlibrary{positioning}

\tikzset{
	box/.style = {
		draw = black,
        fill = white,
		rectangle,
		rounded corners = 2pt,
		text centered,
		minimum height = 5mm,
		minimum width = 10mm
	}
}

\setcopyright{none}

\title{Building and Trusting \R{} Using \Coq{}}
\author{Martin Bodin}
\email{mbodin@dim.uchile.cl}
\affiliation{
    \institution{Center of Mathematical Modeling}
    \streetaddress{Beauchef 851}
    \city{Santiago}
    \country{Chile}
}

\begin{document}

\begin{abstract}
Real-world programming languages have subtil behaviours.
In particular, their semantics is often associated with
various corner cases.
Programmers are usually unaware of all these corner cases,
which can yield to serious bugs.
This is an opportunity for our community
as \Coq{} provides a way to certify the behaviour of a program.
But if the certified program is not written in \Coq{},
such a certification relies on a formal semantics of its programming language.
In the case of a real-world language, such a semantics
can be as difficult to trust as the original program.
Some previous work proposed ways to trust such large semantics.
This work evaluates the feasibility of such a large-scale formalisation
in the case of the \R{} programming languageâ€”%
a trending programming language specialised for statistics computations.
We introduces ProveR, a formalisation of the core of \R{}
related to the reference \R{} interpreter.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:introduction}

\R{}~\parencite{ihaka1996r, Rwebsite} is a trending
programming language for statisticians.
It has a large range of usages (biology, finance, etc.),
as illustrated by the list of available packages categories~\parencite{rviews}.
As a consequence of this diversity,
\R{} programmers come from very different fields of study,
resulting in largely different programming styles.
This makes \R{} unlikely to disappear
in the following years.

The \R{} programming language presents itself
as an expressive and powerful language,
able to express complex notions in few keystrokes.
This sometimes come with the cost of readability.
% it can be difficult to fully understand what a given \R{} program exactly does.
The semantics of \R{} is subtle
and contains numerous corner cases,
as shown in Section~\ref{sec:presentation}.
%
As a consequence, bugs can be frequent in \R{} programs
(as illustrated by the existence of various debugging tools~\parencite{mcpherson2014}),
and trusting such programs can be difficult.
Formal methods in general and the \Coq{} proof assistant in particular
offer an interesting answer to this trust issue.
But to formally prove that an \R{} program meets its specification,
we need a semantics for \R{}.
% Such a semantics needs to be trustworthy.
% In particular, it should capture all the corner cases
% with which a proven program can cope.

A semantics for the full \R{} language will inevitably
be complex, as all corner cases has to be taken into account.
% The question of trusting such a semantics
% then naturally arises.
%
To be able to trust such a formalisation,
it is important to identify \emph{trust sources}.
These can be language specifications,
test suites,
or reference interpreters.
%
% When formalising a complex programming language such as \R{},
Defining the formal model itself
is actually a relatively small part of the formalisation process:
relating it to trust sources
is as important as defining the model.
This relation depends on the kind of available trust sources.

Specifications are the preferred trust source.
They provide a non-ambigous description of the language constructs's behaviours.
A formalisation can be related by similarity:
its constructs and operations should mimic the ones
of the specification.
Ideally, such a similarity would be a line-to-line closeness,
each line of the formalisation referring to a line of the specification,
and conversely.

Test suites provide a large number of programs and their expected result.
When the formalisation is executable, it can be tested against such tests suites.
This technique then enables to evaluate the quality of the test suite
using its code coverage.

Reference interpreters are particularly interesting as
they can be used similarly to either specifications or test suites.
It is indeed possible to relate a formal semantics
to the source code of the reference interpreter,
using it as a specification.
But it is also possible to compare the results of the reference interpreter
and the formal semantics (if executable) on random programs,
until the wanted code coverage is reached.

In the case of \R{}, there is unfortunately
no precise language specification.
There are however some test suites~\parencite{2014testr, maj2013testr},
as well as a reference interpreter~\parencite{team2000r},
from which alternative implementations of \R{} are related.

The \R{} language is large,
but it contains a core which is easy to identify.
We introduce ProveR, a full \Coq{} specification for this core.
The formalisation presents itself as a monadic interpreter.
This interpreter mimics the operations of the reference interpreter,
using its \Cn{} source code as a specification.
%
The next section presents some of the subtleties of the \R{} programming language.
Then Section~\ref{sec:formalisation} presents how our interpreter is defined,
and in particular, how it is related to the \R{} source code.
This project is still in development
and is available at \url{https://github.com/Mbodin/proveR}.


\section{Quick Presentation of \R{}}
\label{sec:presentation}

\R{} is a weakly typed programming language.
Its basic data types mainly consist of various kinds of arrays.
It was originally defined a variant of Scheme
which has been mutated in order to look like its predecessor,
the S programming language~\parencite{ihaka1996r}.
This construction has several implications.
First, functions are first class in \R{}.
Second, \R{} follows the code-is-data paradigm:
it is possible to delay the evaluation of statements,
and even to manipulate their inner structure
(for instance using the \mintinline{R}{substitute} \R{} function).

Actually, almost all constructs of \R{} are treated
as functions taking their subterms as arguments.
This includes features like \mintinline{R}{if}, \mintinline{R}{while},
assignments, etc.
\R{} source code contains a table associating each construct
to a \Cn{} function.
We call this table the \emph{symbol table}.
Some of these functions (like \mintinline{R}{if}, assignments, etc.)
are special and directly manipulate the abstract syntax tree
of their arguments.
The other \Cn{} functions are called after the evaluation of the arguments,
and thus receive a basic type of the language.
%
In this work,
we consider that any feature present in this table
is \emph{not} part of the core of \R{}.
In other words, we define the core of \R{}
as all which is needed to access this table
and execute its \Cn{} functions.

Our definition of the core of \R{} enables us to focus
our formalisation effort on a vary restricted part of the language.
It includes the rules for function calls,
environments, closures, \R{} internals,
as well as all which is necessary to initialise the symbol table.
Constructs like \mintinline{R}{if} and \mintinline{R}{while}
are not part of the core,
but (some kinds of) assignments are
as these parts of the \Cn{} source code
are used during function calls.

We now show some of the corner cases of the \R{} semantics.
Most \R{} constructs adapt themselves when given unusual arguments
to, in some ways, ``guess'' what the programmer meant.
For instance, the \mintinline{R}{i:j} construct
builds a numerical array from the values \mintinline{R}{i}
to \mintinline{R}{j}, which can be any expression.
For instance \mintinline{R}{1:3} is the array containing
the values \(1\), \(2\), and \(3\).
But if the second argument if less than the first argument,
\R{} builds a decreasing array instead of an empty one.
This is a frequent bug pattern when such an expression is involved in a loop.

\begin{minted}{R}
v[i]
\end{minted}

\begin{minted}{R}
f <- function (x, y) if (x == 1) y
f (1, a <- 1); a # Returns 1.
f (0, b <- 1); b # Raises an error.
\end{minted}

None of these corner cases are inherently complex to deal with:
it is the large amount of such exceptions that makes the language complex.


\section{Formalisation}
\label{sec:formalisation}

Trust source used: eyeball closeness.

Description of the closeness.


\section{Related Work}
\label{sec:related:work}

There already have been a large amount of \Coq{} formalisations
of real-world languages.

Formalin.
CompCert.

JSCert.

K and its \Coq{} extraction.
K-Java.


\section{Conclusion and Further Work}
\label{sec:conclusion}

The full project graph.
Show that other trust sources are possible.

Say that this approach may be scalable to other projects.
Languages with reference interpreters:
PHP, Python, etc.


\printbibliography

\end{document}

