
\documentclass[
    sigplan,
    10pt,
    review, % Note: remove the [review] option for the final document.
    natbib=false % Note: This ishere to be able to use Biber.
 ]{acmart}
\let\citename\relax

\settopmatter{printfolios=true,printccs=false,printacmref=false}

\acmConference[DLS'18]{Dynamic Languages Symposium}{November~6, 2018}{Boston, MA, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}

\usepackage{booktabs}
\usepackage{subcaption}

\usepackage[
   backend=biber,
   bibencoding=utf8,
   style=alphabetic,
   hyperref=true,
   % citestyle=authoryear-comp,
   backref=false,
   sortlocale=en,
   url=true,
   doi=false,
   eprint=false
 ]{biblatex}
\addbibresource{biblio.bib}

\usepackage{minted}
\setminted{encoding=utf8}

\usepackage{tikz}
\usetikzlibrary{positioning}

\tikzset{
	box/.style = {
		draw = black,
        fill = white,
		rectangle,
		rounded corners = 2pt,
		text centered,
		minimum height = 5mm,
		minimum width = 10mm
	}
}

\usepackage{todonotes}
\newcommand{\mb}[1]{\todo[color=purple!20,size=\scriptsize]{#1}}
\newcommand{\mbi}[1]{\todo[color=purple!20,inline]{#1}}

\begin{document}

\title{Relating a Formalisation of R to R Itself} % I didn’t thought much about this. Any suggestion?

\author{Martin Bodin}
\orcid{0000-0003-3588-3782}
\affiliation{
  %\position{}
  %\department{Department1}
  \institution{Center of Mathematical Modeling}
  \streetaddress{Beauchef 851}
  \city{Santiago}
  % \state{State1}
  % \postcode{Post-Code1}
  \country{Chile}
}
\email{mbodin@dim.uchile.cl}

\author{Tomás Diaz}
% \authornote{with author2 note}
% \orcid{nnnn-nnnn-nnnn-nnnn}
\affiliation{
  % \position{Position2a}
  \department{DCC}
  \institution{Universidad de Chile}
  \streetaddress{Beauchef 851}
  \city{Santiago}
  % \state{State2a}
  % \postcode{Post-Code2a}
  \country{Chile}
}
\email{toumasaldia@gmail.com} % Shouldn’t we put an address from uchile?

\author{Éric Tanter}
% \authornote{with author2 note}
% \orcid{nnnn-nnnn-nnnn-nnnn}
\affiliation{
  % \position{Position2a}
  \department{DCC}
  \institution{Universidad de Chile}
  \streetaddress{Beauchef 851}
  \city{Santiago}
  % \state{State2a}
  % \postcode{Post-Code2a}
  \country{Chile}
}
\email{etanter@dcc.uchile.cl}

\begin{abstract}
Text of abstract \ldots.
\end{abstract}

% %% 2012 ACM Computing Classification System (CSS) concepts
% %% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
    <ccs2012>
    <concept>
    <concept_id>10003752.10010124.10010131.10010133</concept_id>
    <concept_desc>Theory of computation~Denotational semantics</concept_desc>
    <concept_significance>500</concept_significance>
    </concept>
    </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Denotational semantics}
% %% End of generated code

\keywords{R, Coq, Formalisation, Testing}

\maketitle

\section{Introduction}
\label{sec:intro}

% R is used a lot.
The R programming language~\parencite{R, ihaka1996r, Rwebsite}
has gotten a lot of attention in the recent years.
It is indeed used in a large range of fields (biology, finance, etc.),
and its community ranges over millions of users.
This diversity is reflected among R programmers,
resulting in largely different programming styles.
The language itself is community driven and reflects this diversity.

% R is complex and we need to certify R softwares.
The R programming language is meant to be an expressive and powerful language,
able to express complex notions in few keystrokes.
This sometimes comes with the cost of readability.
The semantics of R is subtle and contains numerous corner cases.
\mb{An small example would be nice here.}
%
Debugging tools exist~\parencite{mcpherson2014},
but such tool can’t always compensate R’s complex semantics.
As a consequence, bugs occurs in R programs
and fully trusting such programs can be difficult.

% We need a formalisation of the language.
Formal methods in general and the Coq proof assistant~\parencite{Coq}
in particular offer an interesting answer to this trust issue.
But to formally prove that an R program meets its specification,
we need a formal semantics of R.
In particular, we want to catch all the subtle cases of R semantics,
such as implicit type conversions.
Indeed, these corner cases are a typical place were bugs appears.
Such a semantics for the full language will inevitably be complex
because of the quantity of such cases.

% This formalisation is quite large, and we need to certify it.
This opens a trust problem:
how can such a large semantics (and hence the proofs made from it)
can be trusted if it is that complex?
To be able to trust such a formalisation,
we need to relate to the R reference interpreters, GNU~R.
This relation of the formalism to trust sources
is not always considered to be an important part of the formalisation process,
but it often needs a large amount of work~\parencite{leroy2014pip}.
Given the size of our formalisation,
we consider this part to be the most important of our contributions.

% Contributions.
We introduce CoqR\mb{Are we fixed on the name? ☺},
a formalisation of the R programming language in the Coq proof assistant.
We also provide two methods to relate this formalisation
to the R reference interpreter.
First, our semantics has been written in a way mimicking R source code.
Second, our semantics is executable and we have extensively tested it
against the reference interpreter.
%
This two-factors method is very close to the one of JSCert,
which we discuss in Section~\ref{sec:related:work}.

% Outlines.
This paper is organised as follows.
Section~\ref{sec:coq:interp} presents the Coq denotational semantics.
In particular, Section~\ref{sec:eyeball:closeness} presents
how this semantics is syntactically close to the C source code of R.
Section~\ref{sec:testing:architecture} then presents our testing architecture.
Not only this architecture is used as a way to relate our semantics
with R reference interpreter,
it also provided immediate benefits during the development of the semantics.
Section~\ref{sec:driving:development} presents these benefits.
The testing results are shown in Section~\ref{sec:test:results}.
Finally, Section~\ref{sec:proofs} presents some proofs that have been done
using our language formalisation.

\section{Coq Interpreter}
\label{sec:coq:interp}

\subsection{Eyeball Closeness}
\label{sec:eyeball:closeness}

We extensively used state + error monads as well as monadic notations
to make every one or two lines of Coq corresponds to one or two lines of C.

Example of C definition / Coq definition.

Size of the project.

\subsection{Difficulties}
\label{sec:coq:difficulties}

C and Coq are widely different programming languages.

A simple model for C’s heap, with unions.
Accesses are unguarded in C, but guarded in Coq.

The [runs] trick to support looping in Coq in a structured way (similar to JSRef).

\subsection{Shim}
\label{sec:shim}

Issues with parsing.
How the parser itself is in a one-to-one correspondance with the original R parser.
Why this still doesn’t prevent us from difference in behaviour.

\section{Testing Architecture}
\label{sec:testing:architecture}

Two goals.
First providing trust to the formalisation by certifying the absence of bugs.
Second, help the development of the formalisation by catching bugs early.

\subsection{Methodology}
\label{sec:test:methodology}

Various kinds of tests (multiline, line-by-line, tests that are expected to fail, etc.).

What is considered to be a failure.

Including the base library.

\subsection{Driving the Development Process}
\label{sec:driving:development}

Identifying low-hanging fruits.

How the other results (Potential fail, Not implemented) helped the Coq development.

\subsection{Results}
\label{sec:test:results}

How much tests are passed and failed.
What does this mean (one line can trigger more than one pass).

Bugs found (and where).

We extended the testing framework during development by adding new kinds of recognised
data structure.
We consider that the amount of work to extend the framework in another direction
(thus reducing the number of Unknown) is sufficiently low.

\section{Proofs}
\label{sec:proofs}

Tactic development.
Given the size of the formalisation, some of these proofs would never have been possible
without some proof automation.
Automation metric: size of the .vo / size of the .v.

Examples of properties that we have proven with our formalisation.

Example of tactic in action:
computeR after an allocation updating all the \verb|safe_pointer|, for instance.

\section{Related Work}
\label{sec:related:work}

FastR
genthat

S5, KJS, JSCert

To a lesser extent, CompCert/Formaline.

\section{Conclusion and Future Work}
\label{sec:conclusion}

We have a fully trustable formalisation of R.

This formalisation can be used to prove program logic in R,
the amount of work for a direct approach being quite large.

We have a testing architecture that can be extended.

We believe our testing framework to be adaptable to other situations,
typically another programming language to be tested.

\printbibliography{}

\end{document}

